
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="referrer" content="no-referrer">
    <base href="https://isthisit.nz/">

    <meta name="description" content="In 1968 a group of computer scientists gathered in Garmisch, Germany for what became known as the NATO Software Engineering Conference. The conference was themed around the apparent software crisis: the world is becoming more reliant on software, yet software systems are getting larger, miss deadlines, go over budget, and are brittle to change. The attendees gathered to discuss this, the factors that contribute to this reality, and propose ways to align the creation of software to the engineering discipline.">

    <link rel="icon" type="image/png" href="https://isthisit.nz/favicon-16x16.png" sizes="16x16">
    <link rel="icon" type="image/png" href="https://isthisit.nz/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="https://isthisit.nz/favicon-96x96.png" sizes="96x96">

    <link type="text/css" rel="stylesheet" href="https://isthisit.nz/css/styles.css" />

    <title>
      
      
         1968 NATO Software Engineering Conference 
      
    </title>
    <link rel="canonical" href="https://isthisit.nz/posts/2022/1968-nato-software-engineering-conference/">

    <link href="https://isthisit.nz/index.xml" rel="alternate" type="application/rss+xml" title="is this it?" />
    
  </head>

  

  <body>
    <section id="nav">
      <div class="page-title">
        <a href="https://isthisit.nz/">is <strong>this</strong> it?</a> 
      </div>

      <div class="page-subtitle" style="font-size: 0.9em; color: #6e6d6d">
        <em>sunsets are photons & atoms, not bits <a href="https://isthisit.nz/index.xml"><img class="rss-icon" src="https://isthisit.nz/img/rss.svg" alt="RSS" /></a></em>
      </div>
      <ul>
        
          <li><a href="https://isthisit.nz/curated">Curated Posts</a></li>

          
          <li class="unselectable muted icon-item">Œ¥</li>
          

        
          <li><a href="https://isthisit.nz/categories/photos/">Photography</a></li>

          
          <li class="unselectable muted icon-item">Œ¥</li>
          

        
          <li><a href="https://isthisit.nz/archive">Archive</a></li>

          

        
      </ul>
    </section>


<section id="middle-container">

  <div id="content" class="single-post">
    <h1> 1968 NATO Software Engineering Conference </h1>

    <div class=sub-header>
      August 29 2022 ¬∑ <a class="label label-default" href="https://isthisit.nz/tags/tech/">tech</a> <a class="label label-default" href="https://isthisit.nz/tags/software-engineering/">software-engineering</a> 
    </div>

    <div class="entry-content" data-pagefind-body>
      <p>In 1968 a group of computer scientists gathered in Garmisch, Germany for what became known as the NATO Software Engineering Conference. The conference was themed around the apparent software crisis: the world is becoming more reliant on software, yet software systems are getting larger, miss deadlines, go over budget, and are brittle to change. The attendees gathered to discuss this, the factors that contribute to this reality, and propose ways to align the creation of software to the engineering discipline.</p>
<p>The Garmisch conference produced a 100 page report titled <a href="https://static.isthisit.nz/images/2022-08-nato-software-engineering/static/software-engineering-nato-1968.PDF">Software Engineering</a>. The report, edited by Brian Randell and Peter Naur, is a collection of conversations, quotes and paper extracts from the conference. In this post I share extracts from the report coupled with my own understanding of the context of software in 1968. I highlight the ideas that are both eerily similar and radically different from the realities we face in software systems today.</p>
<a class="hash-link" href=" https://isthisit.nz/posts/2022/1968-nato-software-engineering-conference/#setting-the-scene">
    <h2 id="setting-the-scene">
    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="black" class="muted" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <title>Link to this section</title>
        <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
        <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
    </svg>
    Setting the Scene
    </h2>
</a>
<p>It&rsquo;s 1968 and there are 10,000 computers in Europe. This number is set to double every year. A group of 40 academics gather for the Garmisch conference. NATO sponsors it so they send a few people along to listen and learn.</p>
<figure class="full-width"><img src="https://static.isthisit.nz/images/2022-08-nato-software-engineering/conference-photo.png" class="lightbox-image"
         alt="Photograph from the conference."/><figcaption>
            <h4>Photograph from the conference.</h4></figcaption>
</figure>

<p>Some of the names we may recognise today are Edsger Dijkstra, CAR Hoare, Alan Perlis, Peter Naur, and Niklaus Wirth. The attendees are largely from a scientific background, and rotate between industry jobs and academia. They typically work on systems such as operating systems, compilers, and programming languages.</p>
<p>The &lsquo;software gap&rsquo; (at other times called the &lsquo;software crisis&rsquo;) is summarised as follows:</p>
<blockquote>
<p>The basic problem is that certain classes of systems are placing demands on us which are beyond our capabilities and our theories and methods of design and production at this time. There are many areas where there is no such thing as a crisis ‚Äî sort routines, payroll applications, for example. It is large systems that are encountering great difficulties. We should not expect the production of such systems to be easy.<br><br>
Kenneth Kolence - Software Engineering (1968) pg 71</p></blockquote>
<p>It&rsquo;s not just that software is becoming more complex, it&rsquo;s that computer systems are playing a greater role in society. In 1968 computers were used for data processing at large companies and institutions. Personal computers weren&rsquo;t yet available.</p>
<a class="hash-link" href=" https://isthisit.nz/posts/2022/1968-nato-software-engineering-conference/#software">
    <h2 id="software">
    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="black" class="muted" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <title>Link to this section</title>
        <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
        <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
    </svg>
    Software
    </h2>
</a>
<p>In the 1960s the term Software referred to the tools used to construct other programs: operating systems, compilers, and programming languages. Everything that ran on top of software such as payroll systems and calculators were <em>applications</em>. Thomas Haigh&rsquo;s <a href="https://static.isthisit.nz/images/2022-08-nato-software-engineering/static/software-in-the-1960s-haigh.pdf">Software in the 1960s as concept, service, and product</a> provides a view into that world.</p>
<p>Conference attendee d&rsquo;Agapeyeff presents this model as the stack that applications run on. He describes it as &ldquo;very sensitive to weaknesses in the software&rdquo;</p>
<figure class="full-width"><img src="https://static.isthisit.nz/images/2022-08-nato-software-engineering/inverted-pyramid.png" class="lightbox-image"
         alt="d&rsquo;Agapeyeff&rsquo;s inverted pyramid model."/><figcaption>
            <h4>d&#39;Agapeyeff&#39;s inverted pyramid model.</h4></figcaption>
</figure>

<blockquote>
<p>This sensitivity of software can be understood if we liken it to what I will call the inverted pyramid. The buttresses are assemblers and compilers. They don&rsquo;t help to maintain the thing, but if they fail you have a skew. At the bottom are the control programs, then the various service routines. Further up we have what I call middleware.<br><br>
This is because no matter how good the manufacturer&rsquo;s software for items like file handling it is just not suitable; it&rsquo;s either inefficient or inappropriate. We usually have to rewrite the file handling processes, the initial message analysis and above all the real-time schedulers, because in this type of situation the application programs interact and the manufacturers, software tends to throw them off at the drop of a hat, which is somewhat embarrassing. On the top you have a whole chain of application programs.<br><br>
The point about this pyramid is that it is terribly sensitive to change in the underlying software such that the new version does not contain the old as a subset. It becomes very expensive to maintain these systems and to extend them while keeping them live.<br><br>
d&rsquo;Adapeyeff - Software Engineering (1968) pg 14</p></blockquote>
<p>Today&rsquo;s abstraction of hardware, operating systems, and applications was also different. Hardware manufacturers bundled the operating system with the hardware they were selling. Multi target compilers such as GCC and LLVM did not exist, nor interpreted languages that support the combinations of different operating systems and hardware such as Python and NodeJS. Mainframe systems would have different memory layouts and processors so software had to be written for a particular mainframe. Write once, run anywhere wasn&rsquo;t even a joke.</p>
<p>Software such as compilers and schedulers, already coupled to a mainframe, had to abstract over the mainframe&rsquo;s system APIs in order to remove faults. Applications could then be built using these compilers. Leaky abstractions are a reality, and so applications being built were forced to consider the mainframe operating system, compiler, and quirks of the combination of the two.</p>
<blockquote>
<p>The scope of this conference is not large enough ‚Ä¶ We should start by designing hardware and software together. This will require a kind of general-purpose person, a ‚Äòcomputer engineer&rsquo;.<br><br>
Barton - Software Engineering (1968) pg 21</p></blockquote>
<p>This problem of fragile software and applications due to underlying hardware and operating system quality has been largely solved today through abstraction. We can write high level Python code which operates on files and be reasonably confident that it will run consistently wherever Python can. Indeed conference attendee Babcock saw this future.</p>
<blockquote>
<p>The future of new operating system developments in the future may depend more and more on new hardware just on the horizon. The advent of slow-write, read-only stores makes it possible for the software designer to depend on a viable machine that has flexible characteristics as opposed to rigid operation structures found in most of today&rsquo;s machines. If the software designer had access to a microprogramming high-level language compiler, then systems could be designed to the specific problem area without severe hardware constraints. Major U. S. manufacturers including IBM, UNIVAC, Standard Computer, RCA are building or seriously considering such enhancements. <br><br>
Babcock - Software Engineering (1968) pg 21</p></blockquote>
<p>Today we still need to know about the hardware our code will run on. There&rsquo;s a lot of variation between systems: Compute resource allocation for our services, IO characteristics for read/write heavy workloads, and in the case of software consumed by customers we need to know what hardware they&rsquo;re using: phones, tablets, screen sizes, keyboards, etc.</p>
<p>The largest and most problematic hardware issue most software engineers face today are networks. Not something the attendees of the Garmisch needed to wrestle with. We can think of networks introducing a couple of categories of complexity.</p>
<p>The first is the unreliability and variability that happens within the various layers of the network stack (think latency and routing). We write defensive code to be resilient to network faults and incur the cost of complex code as we move operations to asynchronous and retryable workflows. There&rsquo;s also a category of undefined behaviour of our systems when critical dependencies go down, or worse slow down. For example if the authentication server goes down then the application doesn&rsquo;t work. If the authentication server responds at 100x the median response rate what happens?</p>
<p>The second is fundamental to what networks allow us to construct. Systems can now span many computers and APIs. The systems talked about in 1968 ran only on a single machine. Even then the attendees talk about how sensitive and fragile the software system is. Today an HTTP request to a reasonably large SaaS product may cause a ripple on tens or hundreds of machines. How would we compare the fragility of software systems today to those of 54 years ago?</p>
<a class="hash-link" href=" https://isthisit.nz/posts/2022/1968-nato-software-engineering-conference/#software-engineering">
    <h2 id="software-engineering">
    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="black" class="muted" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <title>Link to this section</title>
        <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
        <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
    </svg>
    Software Engineering
    </h2>
</a>
<p>The editors of the report give us insight to the phrase software engineering:</p>
<blockquote>
<p>The phrase ‚Äòsoftware engineering&rsquo; was deliberately chosen as being provocative, in implying the need for software manufacture to be based on the types of theoretical foundations and practical disciplines that are traditional in the established branches of engineering.<br><br>
Editors - Software Engineering (1968) pg</p></blockquote>
<p>This is something we still aspire to today. When we fly on a plane we wish that the software that flies it was developed through an engineering rather than artistic methodology. The report attendees discussed two ways to get there: the industrialisation of software, and formal mathematics.</p>
<p>M.D McIlroy presents Mass Produced Software Components at the Garmisch Conference. The entire paper is worth a read. Abstract below:</p>
<blockquote>
<p>Software components (routines), to be widely applicable to different machines and users, should be available in families arranged according to precision, robustness, generality and timespace performance. Existing sources of components ‚Äî manufacturers, software houses, users&rsquo; groups and algorithm collections ‚Äî lack the breadth of interest or coherence of purpose to assemble more than one or two members of such families, yet software production in the large would be enormously helped by the availability of spectra of high quality routines, quite as mechanical design is abetted by the existence of families of structural shapes, screws or resistors.<br><br>
McIlroy - Software Engineering (1968) pg 79</p></blockquote>
<p>He makes the case that we should view the creation of software through the lens of mass production.</p>
<blockquote>
<p>When we undertake to write a compiler, we begin by saying ‚ÄòWhat table mechanism shall we build?&rsquo; Not, ‚ÄòWhat mechanism shall we use? but ‚ÄòWhat mechanism shall we build? I claim we have done enough of this to start taking such things off the shelf.<br><br>
McIlroy - Software Engineering (1968) pg 80</p></blockquote>
<p>In today&rsquo;s context we have open source programming languages and systems with well supported ecosystems. In terms of technology choices, open source has got us some of the way to <em>‚Äòwhich mechanism shall we use?&rsquo;</em> Engineers pick common databases, web frameworks, and libraries. Though from that starting point we&rsquo;re quite happy to change the frame back to <em>‚Äòwhich mechanism shall we build?&rsquo;</em></p>
<p>Programming started from mathematical roots and the call for the formalisation of systems continues on to today.</p>
<blockquote>
<p>There is no theory which enables us to calculate limits on the size, performance, or complexity of software. There is, in many instances, no way even to specify in a logically tight way what the software product is supposed to do or how it is supposed to do it. We can wish that we had the equivalent of Shannon&rsquo;s information theorems, which tell how much information can be transmitted over a channel of given bandwidth and given signal-to-noise ratio, or Winograd&rsquo;s theorem specifying the minimum addition time, given the switching and delay times in the basic circuitry, but we don&rsquo;t have such existence limits for software. <br><br>
David - Software Engineering (1968) pg 39</p></blockquote>
<p>The thing with correctness is that you either have it or you don&rsquo;t. Today we don&rsquo;t, but useful mechanisms such as more advanced types systems are creeping into mainstream languages. Type systems provide some level of safety, but a greater benefit to the programmer to help them understand the code base.</p>
<p>Gillette and Perlis continue the tradition of John Wilkins and Leibniz. Shortcomings are the result of not having a formal language.</p>
<blockquote>
<p>One type of error we have to contend with is inconsistency of specifications. I think it is probably impossible to specify a system completely free of ambiguities, certainly so if we use a natural language, such as English. If we had decent specification languages, which were non-ambiguous, perhaps this source of error could be avoided.<br><br>
Gillette - Software Engineering (1968) pg 35</p></blockquote>
<p>Perlis refines this:</p>
<blockquote>
<p>However, there is another reason why people don&rsquo;t do predocumentation: They don&rsquo;t have a good language for it since we have no way of writing predicates describing the state of a computation.<br><br>
Perlis - Software Engineering (1968) pg 35</p></blockquote>
<a class="hash-link" href=" https://isthisit.nz/posts/2022/1968-nato-software-engineering-conference/#software-is-designed-and-produced">
    <h2 id="software-is-designed-and-produced">
    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="black" class="muted" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <title>Link to this section</title>
        <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
        <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
    </svg>
    Software is Designed and Produced
    </h2>
</a>
<p>Software was first designed, then the plans were handed over to designers to produce the software according to the specification (write the code). We know this doesn&rsquo;t work today, and the attendees at Garmisch also highlighted the same reasons why. What&rsquo;s curious is that they seem to want software to be designable before any code is written.</p>
<p>First a quote from Naur. Emphasis mine.</p>
<blockquote>
<p>Software production takes us from the result of the design to the program to be executed in the computer. <strong>The distinction between design and production is essentially a practical one, imposed by the need for a division of the labor</strong>. In fact, there is no essential difference between design and production, since even the production will include decisions which will influence the performance of the software system, and thus properly belong in the design phase. <strong>For the distinction to be useful, the design work is charged with the specific responsibility that it is pursued to a level of detail where the decisions remaining to be made during production are known to be insignificant to the performance of the system</strong>.<br><br>
Naur - Software Engineering (1968) pg 20</p></blockquote>
<p>The middle of the quote talks about there is no difference between design and production. Design is continuously evolving, and during implementation the writers of software discover new things and need to make decisions on the fly. That&rsquo;s the same reality we see today. But the two sections I emphasised hint that there needs to be a designer.</p>
<p>Likewise this quote from Dijkstra.</p>
<blockquote>
<p>Honestly, I cannot see how these activities [Design, Production] allow a rigid separation if we are going to do a decent job. If you have your production group, it must produce something, but the thing to be produced has to be correct, has to be good. However, I am convinced that the quality of the product can never be established afterwards. Whether the correctness of a piece of software can be guaranteed or not depends greatly on the structure of the thing made. This means that the ability to convince users, or yourself, that the product is good, is closely intertwined with the design process itself.<br><br>
Dijkstra - Software Engineering (1968) pg 20</p></blockquote>
<p>I get the impression that the attendees understood that the design couldn&rsquo;t be done up front, but that if the software was written according to the eventually evolved design then the software would work as intended. Perhaps this was due to the nature of the systems they worked on ‚Äì compilers and other systems programming with very formal correctness criteria. I think of products and SaaS I&rsquo;ve worked on where indeed the software was written according to the design, but the eventual behaviour of how the software should be used was completely emergent. It&rsquo;s like the organisation puts together a collection of microservices and user interfaces, each of which are verified and tested independently and in specific combinations. But the operation and behaviour of the system as a whole is completely defined by the customer. They know where the buggy screens are, they know they need to configure a record in a specific way before submitting it, etc.</p>
<p>An unsolved problem in Software Engineering today is how we can resolve and align internal and external designs and documentation. Complex systems typically have hundreds of pages of customer documentation describing how the system works and what actions they need to take to get the outcome they want. Behind this singular SaaS presented to the customer are hundreds of microservices, databases, and workers. These all come with code-level architecture, design, and documentation. In practice the external documentation defines the actual behaviour of the system. But when a programmer is working at the code level how can they be presented with the relevant set of data they need to make a decision? It&rsquo;s like we need forever up to date links and connections between internal and external documentation. Kolence presents this:</p>
<blockquote>
<p>Another area of difficulty which faces the designer of a program is how to relate the descriptions of the external and internal designs. The notation of external characteristics tends to be narrative and tabular, whereas internal design notation normally consists of flow charts and statements about key internal containers and tables. An external set of characteristics which is appropriately cross-referenced to the internal design, and which clearly illustrates the impact of features or sets of features on the internal design would be of great value to both the designer and the manager.<br><br>
Kolence - Software Engineering (1968) pg 34</p></blockquote>
<p>Is this solvable through technology? (probably not).</p>
<blockquote>
<p>A standard for program documentation when programs are written in symbolic machine language should be set and each program should include this standard documentation in the ‚Äòremarks field&rsquo; of the symbolic program.<br><br>
This documentation should include sufficient information and in such a way that a computer program can flow trace any program according to specified conditions.<br><br>
Then a computer program can be used to assist in evaluating and checking the progress of the program design. Computer studies of the realtime used under varying conditions can be made and studies to see that memory interfaces are satisfied can be made.<br><br>
Harr - Software Engineering (1968) pg 52</p></blockquote>
<a class="hash-link" href=" https://isthisit.nz/posts/2022/1968-nato-software-engineering-conference/#the-scale-of-software-systems">
    <h2 id="the-scale-of-software-systems">
    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="black" class="muted" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <title>Link to this section</title>
        <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
        <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
    </svg>
    The Scale of Software Systems
    </h2>
</a>
<p>Attendees saw the ever increasing scale of software being a problem. Both from the count of lines of code, as well as the number of people required to work on a single system.</p>
<p>In the context of the apparent ‚Äòsoftware crisis&rsquo; graphs such as below are intimidating.</p>
<blockquote>
<p>Production of large software has become a scare item for management. By reputation it is often an unprofitable morass, costly and unending. This reputation is perhaps deserved. No less a person than T. J. Watson said that OS/360 cost IBM over 50 million dollars a year during its preparation, and at least 5000 man-years&rsquo; investment. TSS/360 is said to be in the 1000 man-year category. It has been said, too, that development costs for software equal the development costs for hardware in establishing a new machine line.<br><br>
David - Software Engineering (1968) pg 37</p></blockquote>
<figure class="full-width"><img src="https://static.isthisit.nz/images/2022-08-nato-software-engineering/lines-of-code.png" class="lightbox-image"
         alt="Lines of code in Mainframe systems."/><figcaption>
            <h4>Lines of code in Mainframe systems.</h4></figcaption>
</figure>

<blockquote>
<p>I am concerned about the current growth of systems, and what I expect is probably an exponential growth of errors. Should we have systems of this size and complexity? Is it the manufacturer&rsquo;s fault for producing them or the user&rsquo;s for demanding them? One shouldn&rsquo;t ask for large systems and then complain about their largeness.<br><br>
Opler - Software Engineering (1968) pg 61</p></blockquote>
<p>I underline that the software systems they are talking about run on a single machine. This is before networked systems were widely used! Today the majority of systems are distributed systems. The subsystems which make up the whole communicate using APIs and protocols. Subsystems can be developed by smaller teams, reducing cost to coordinate at the code level (the DevOps ‚Äúsmall autonomous team‚Äù). Subsystems can also be deployed and scaled separately, allowing compute and storage resources to be right sized to the workload. Even though the paradigm of software systems has shifted, many of the comments from the 1968 conference are still relevant.</p>
<blockquote>
<p>The good systems that are presently working were written by small groups. More than twenty programmers working on a project is usually disastrous.<br><br>
Buxton - Software Engineering (1968) pg 39</p></blockquote>
<p>At a subsystem level, this is debatably true today. And yet Perlis&rsquo; argument below for why software must scale applies at the larger system level.</p>
<blockquote>
<p>We kid ourselves if we believe that software systems can only be designed and built by a small number of people. If we adopt that view this subject will remain precisely as it is today, and will ultimately die. We must learn how to build software systems with hundreds, possibly thousands of people. It is not going to be easy, but it is quite clear that when one deals with a system beyond a certain level of complexity, e.g. IBM&rsquo;s TSS/360, regardless of whether well designed or poorly designed, its size grows, and the sequence of changes that one wishes to make on it can be implemented in any reasonable way only by a large body of people, each of whom does a mole&rsquo;s job.<br><br>
Perlis - Software Engineering (1968) pg 39</p></blockquote>
<a class="hash-link" href=" https://isthisit.nz/posts/2022/1968-nato-software-engineering-conference/#planning-and-estimates">
    <h2 id="planning-and-estimates">
    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="black" class="muted" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <title>Link to this section</title>
        <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
        <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
    </svg>
    Planning and Estimates
    </h2>
</a>
<p>Commentary on the difficulty of planning, and apparent impossibility of estimating software projects hasn&rsquo;t changed in the last 54 years. I highlight this to contrast to the earlier quotes around Software Design. Compared to today, there was more effort put in the upfront design and a want (if not belief) that the design could be ‚Äòcorrect&rsquo;. That considered, estimates were not remotely accurate.</p>
<blockquote>
<p>Computing has one property, unique I think, that seriously aggravates the uncertainties associated with soft- ware efforts. In computing, the research, development, and production phases are often telescoped into one process. In the competitive rush to make available the latest techniques, such as on-line consoles served by time- shared computers, we strive to take great forward leaps across gulfs of unknown width and depth. In the cold light of day, we know that a step-by-step approach separating research and development from production is less risky and more likely to be successful. Experience indeed indicates that for software tasks similar to previous ones, estimates are accurate to within 10‚Äì30% in many cases. This situation is familiar in all fields lacking a firm theoretical base. Thus, there are good reasons why software tasks that include novel concepts involve not only uncalculated but also uncalculable risks.<br><br>
David - Software Engineering (1968) pg 41</p></blockquote>
<figure class="full-width"><img src="https://static.isthisit.nz/images/2022-08-nato-software-engineering/nash-project-estimation.png" class="lightbox-image"
         alt="Nash Illustrating Projects Estimate vs Actual Time"/><figcaption>
            <h4>Nash Illustrating Projects Estimate vs Actual Time</h4></figcaption>
</figure>

<p>They likewise highlight sometimes who is doing the job is often a better indicator than the complexity or size of the job. Something we seem to forget today.</p>
<blockquote>
<p>I would never dare to quote on a project unless I knew the people who were to be involved.<br><br>
Fraser - Software Engineering (1968) pg 50</p></blockquote>
<a class="hash-link" href=" https://isthisit.nz/posts/2022/1968-nato-software-engineering-conference/#engineering-metrics">
    <h2 id="engineering-metrics">
    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="black" class="muted" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <title>Link to this section</title>
        <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
        <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
    </svg>
    Engineering Metrics
    </h2>
</a>
<p>In my day job I lead development of an Engineering Metrics application. While not a section of the Garmisch Report, I&rsquo;ve selected a few quotes.</p>
<blockquote>
<p>One of the problems that is central to the software production process is to identify the nature of progress and to find some way of measuring it. Only one thing seems to be clear just now. It is that program construction is not always a simple progression in which each act of assembly represents a distinct forward step and that the final product can be described simply as the sum of many sub-assemblies.<br><br>
Fraser - Software Engineering (1968) pg 51</p></blockquote>
<p>In modern metrics lingo we know that ‚Äòoutput metrics&rsquo; are next to useless. These are metrics such as lines of code, number of commits, and number of pull requests. These metrics tell us that code has been added to the system, but due to the nature of software systems we don&rsquo;t know if it delivered value, got the system any closer to completion, or added a bug.</p>
<blockquote>
<p>I know of one organisation that attempts to apply time and motion standards to the output of programmers. They judge a programmer by the amount of code he produces. This is guaranteed to produce insipid code ‚Äî code which does the right thing but which is twice as long as necessary.<br><br>
McClure - Software Engineering (1968) pg 52</p></blockquote>
<p>This model of Software Design and Software Production comes into play here. If the Design describes exactly what needs to be built, then we can measure progress by the programmers checking parts off as they implement it.</p>
<blockquote>
<p>Each program designer&rsquo;s work should be scheduled and bench marks established along the way so that the progress of both of his documentation and programs can be monitored. (Here we need a yardstick for measuring a programmer&rsquo;s progress other than just program words written.) The yardstick should measure both what has been designed and how, from the standpoint of meeting the design requirements. Programmers should be required to flowchart and describe their programs as they are developed, in a standard way. The bench marks for gauging the progress of the work should be a measure of both the documents and program produced in a given amount of time.<br><br>
Harr - Software Engineering (1968) pg 52</p></blockquote>
<p>On milestones.</p>
<blockquote>
<p>The main interest of management is in knowing what progress has been made towards reaching the final goal of the project. The difficulty is to identify observable events which mark this progress.<br><br>
Kolence - Software Engineering (1968) pg 52</p></blockquote>
<a class="hash-link" href=" https://isthisit.nz/posts/2022/1968-nato-software-engineering-conference/#things-that-havent-changed-in-54-years">
    <h2 id="things-that-havent-changed-in-54-years">
    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="black" class="muted" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <title>Link to this section</title>
        <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
        <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
    </svg>
    Things That Haven&rsquo;t Changed in 54 Years
    </h2>
</a>
<p>Measuring progress on the construction of a system.</p>
<blockquote>
<p>One of the problems that is central to the software production process is to identify the nature of progress and to find some way of measuring it. Only one thing seems to be clear just now. It is that program construction is not always a simple progression in which each act of assembly represents a distinct forward step and that the final product can be described simply as the sum of many sub-assemblies.<br><br>
Fraser - Software Engineering (1968) pg 10</p></blockquote>
<p>Lean Software Development.</p>
<blockquote>
<p>Define a subset of the system which is small enough to bring to an operational state ‚Ä¶ then build on that subsystem. This strategy requires that the system be designed in modules which can be realized, tested, and modified independently.<br><br>
David - Software Engineering (1968) pg 24</p></blockquote>
<p>Resilience Engineering.</p>
<blockquote>
<p>I just want to make the point that reliability really is a design issue, in the sense that unless you are conscious of the need for reliability throughout the design, you might as well give up.<br><br>
Fraser - Software Engineering (1968) pg 26</p></blockquote>
<p>Engineers must be equipped with the right tools to do the job.</p>
<blockquote>
<p>A reliable, working system incorporating advanced programming and debugging tools must be available from the beginning. One requirement is an accessible file system for storing system modules and prototypes. An adequate file system should act as a common work space for system programmers and should have back-up facilities to insure against loss of valuable records.<br><br>
David - Software Engineering (1968) pg 55</p></blockquote>
<a class="hash-link" href=" https://isthisit.nz/posts/2022/1968-nato-software-engineering-conference/#conclusion">
    <h2 id="conclusion">
    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="black" class="muted" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <title>Link to this section</title>
        <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
        <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
    </svg>
    Conclusion
    </h2>
</a>
<p>Reading the report about the 1968 NATO Conference was fascinating. Some of the ideas and problems are identical to what we talk about at the coffee machine today. Other problems we can only dream of, having been solved in the layers of abstraction of systems we build upon.</p>
<p>I&rsquo;ve presented only a fraction of what is talked about in the report. If any of this interests you then check out the report and other material in the links below.</p>
<a class="hash-link" href=" https://isthisit.nz/posts/2022/1968-nato-software-engineering-conference/#references">
    <h2 id="references">
    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="black" class="muted" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <title>Link to this section</title>
        <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
        <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
    </svg>
    References
    </h2>
</a>
<ul>
<li><a href="https://static.isthisit.nz/images/2022-08-nato-software-engineering/static/software-engineering-nato-1968.PDF">NATO Software Engineering Report 1968</a> - Peter Naur and Brian Randell.</li>
<li><a href="https://static.isthisit.nz/images/2022-08-nato-software-engineering/static/software-in-the-1960s-haigh.pdf">Software in the 1960s as Concept, Service, and Product</a> - Thomas Haigh.</li>
<li><a href="https://static.isthisit.nz/images/2022-08-nato-software-engineering/static/what-crisis-haigh.pdf">Crisis, What Crisis?</a> - Thomas Haigh.</li>
<li><a href="https://static.isthisit.nz/images/2022-08-nato-software-engineering/static/the-roots-of-software-engineering.pdf">The Roots of Software Engineering</a> - Michael S Mahoney.</li>
<li><a href="https://static.isthisit.nz/images/2022-08-nato-software-engineering/static/oral-history-kennth-kolence.pdf">2001 interview with Kenneth Kolence</a> - Jeffrey Yost.</li>
</ul>

    </div>

    <hr>

    
    
    <hr>

    <div>
      <h3 title="As determined by the blogging software">Related Posts</h3>

      
        
        <ul>
          
          <li><a href="https://isthisit.nz/posts/2022/delivery-lead-time-in-practice/">Delivery Lead Time In Practice</a></li>
          
          <li><a href="https://isthisit.nz/posts/2022/cargo-culting-software-engineering-practices/">Cargo Culting Software Engineering Practices</a></li>
          
          <li><a href="https://isthisit.nz/posts/2022/ic-initiatives-at-big-tech/">IC Initiatives at Big Tech</a></li>
          
          <li><a href="https://isthisit.nz/posts/2022/design-from-zero/">Design from Zero</a></li>
          
          <li><a href="https://isthisit.nz/posts/2022/longitude-visualise-git-repositories/">Longitude: Visualise Git Respositories</a></li>
          
        </ul>
        
    </div>

    <div id=links>
      
        <a class="basic-alignment left" href="https://isthisit.nz/posts/2022/delivery-lead-time-in-practice/">&laquo; Delivery Lead Time In Practice</a>
      
      
        <a class="basic-alignment left" href="https://isthisit.nz/posts/2022/brisbane/">Brisbane Photography &raquo;</a>
      
    </div>
  </div>

  

<div id="sidebar">
    
    <span class="column-header">Recent Posts</span>
    <ul>
    
        <li class="recent-post"><a href="https://isthisit.nz/posts/2025/melbourne-photography-xiii/">Melbourne Photography XIII</a></li>
    
        <li class="recent-post"><a href="https://isthisit.nz/posts/2025/seven-weeks-with-the-camera-among-the-glaciers-of-mt-cook/">Seven Weeks with the Camera among the Glaciers of Mt Cook</a></li>
    
        <li class="recent-post"><a href="https://isthisit.nz/posts/2025/melbourne-photography-xii/">Melbourne Photography XII</a></li>
    
        <li class="recent-post"><a href="https://isthisit.nz/posts/2025/analog-photography-assistant-110/">Analog Photography Assistant - 1.1.0</a></li>
    
        <li class="recent-post"><a href="https://isthisit.nz/posts/2025/pine-smoke/">Pine Smoke</a></li>
    
        <li class="recent-post"><a href="https://isthisit.nz/posts/2025/writing-software-with-llms/">Writing Software with LLMs</a></li>
    
    </ul>

    <div class="separator">
        <span class="unselectable">
                Œª
        </span>
    </div>
    
    <div>
        <span class="column-header">¬ßearch</span>
        <form method="get" action="https://isthisit.nz/search/">
            <label for="search" style="display: none">Search</label>

            <input type="text" id="search" name="term" placeholder="" /> &nbsp; <button type="submit" id="search-button">‚åï</button>
        </form>
    </div>
















    <div class="separator">
        <span class="unselectable">
                Œª
        </span>
    </div>
    
    <span class="column-header">ùïãags</span>
    <div style="line-height: 1.7em">
    
    
    
    
    
    
    <a href="https://isthisit.nz/tags/tech" class="tag">tech <span>(52)</span></a>
    
    
    
    
    <a href="https://isthisit.nz/tags/landscape-photography" class="tag">landscape-photography <span>(47)</span></a>
    
    
    
    
    <a href="https://isthisit.nz/tags/software-engineering" class="tag">software-engineering <span>(43)</span></a>
    
    
    
    
    <a href="https://isthisit.nz/tags/film-photography" class="tag">film-photography <span>(26)</span></a>
    
    
    
    
    <a href="https://isthisit.nz/tags/central-otago" class="tag">central-otago <span>(20)</span></a>
    
    
    
    
    <a href="https://isthisit.nz/tags/hellenic" class="tag">hellenic <span>(16)</span></a>
    
    
    
    
    <a href="https://isthisit.nz/tags/monochrome" class="tag">monochrome <span>(16)</span></a>
    
    
    
    
    <a href="https://isthisit.nz/tags/devops" class="tag">devops <span>(15)</span></a>
    
    
    
    
    <a href="https://isthisit.nz/tags/melbourne" class="tag">melbourne <span>(15)</span></a>
    
    
    
    
    <a href="https://isthisit.nz/tags/books" class="tag">books <span>(14)</span></a>
    
    
    
    
    <a href="https://isthisit.nz/tags/fsharp" class="tag">fsharp <span>(14)</span></a>
    
    
    
    
    <a href="https://isthisit.nz/tags/dotnet" class="tag">dotnet <span>(13)</span></a>
    
    
    
    
    <a href="https://isthisit.nz/tags/poems" class="tag">poems <span>(13)</span></a>
    
    
    
    
    <a href="https://isthisit.nz/tags/street-photography" class="tag">street-photography <span>(13)</span></a>
    
    
    
    
    <a href="https://isthisit.nz/tags/astro-photography" class="tag">astro-photography <span>(12)</span></a>
    
    
    
    
    <a href="https://isthisit.nz/tags/lawrence-durrell" class="tag">lawrence-durrell <span>(9)</span></a>
    
    
    
    
    <a href="https://isthisit.nz/tags/philosophy" class="tag">philosophy <span>(9)</span></a>
    
    
    
    
    <a href="https://isthisit.nz/tags/complexity" class="tag">complexity <span>(8)</span></a>
    
    
    
    
    <a href="https://isthisit.nz/tags/continuous-deployment" class="tag">continuous-deployment <span>(8)</span></a>
    
    
    
    
    <a href="https://isthisit.nz/tags/travel-writing" class="tag">travel-writing <span>(8)</span></a>
    
    
    
    
    <a href="https://isthisit.nz/tags/accelerate" class="tag">accelerate <span>(7)</span></a>
    
    
    
    
    <a href="https://isthisit.nz/tags/computation" class="tag">computation <span>(7)</span></a>
    
    
    
    
    <a href="https://isthisit.nz/tags/dunedin" class="tag">dunedin <span>(6)</span></a>
    
    
    
    
    <a href="https://isthisit.nz/tags/resilience-engineering" class="tag">resilience-engineering <span>(6)</span></a>
    
    
    
    
    <a href="https://isthisit.nz/tags/aws" class="tag">aws <span>(5)</span></a>
    
    
    
    
    <a href="https://isthisit.nz/tags/tasmania" class="tag">tasmania <span>(5)</span></a>
    
    
    
    
    <a href="https://isthisit.nz/tags/ai" class="tag">ai <span>(4)</span></a>
    
    
    
    
    <a href="https://isthisit.nz/tags/cavafy" class="tag">cavafy <span>(4)</span></a>
    
    
    
    
    <a href="https://isthisit.nz/tags/george-seferis" class="tag">george-seferis <span>(4)</span></a>
    
    
    
    
    <a href="https://isthisit.nz/tags/linux" class="tag">linux <span>(4)</span></a>
    
    
    
    
    <a href="https://isthisit.nz/tags/lparen" class="tag">lparen <span>(4)</span></a>
    
    
    
    
    <a href="https://isthisit.nz/tags/southland" class="tag">southland <span>(4)</span></a>
    
    
    
    
    <a href="https://isthisit.nz/tags/wanaka" class="tag">wanaka <span>(4)</span></a>
    
    
    
    
    <a href="https://isthisit.nz/tags/analog-photography-assistant" class="tag">analog-photography-assistant <span>(3)</span></a>
    
    
    
    
    <a href="https://isthisit.nz/tags/aurora" class="tag">aurora <span>(3)</span></a>
    
    
    
    
    <a href="https://isthisit.nz/tags/python" class="tag">python <span>(3)</span></a>
    
    
    
    
    <a href="https://isthisit.nz/tags/queenstown" class="tag">queenstown <span>(3)</span></a>
    
    
    
    
    <a href="https://isthisit.nz/tags/stories" class="tag">stories <span>(3)</span></a>
    
    
    
    
    <a href="https://isthisit.nz/tags/tekapo" class="tag">tekapo <span>(3)</span></a>
    
    
    
    
    <a href="https://isthisit.nz/tags/wellington" class="tag">wellington <span>(3)</span></a>
    
    
    
    
    <a href="https://isthisit.nz/tags/brighton" class="tag">brighton <span>(2)</span></a>
    
    
    
    
    <a href="https://isthisit.nz/tags/cellular-automata" class="tag">cellular-automata <span>(2)</span></a>
    
    
    
    
    <a href="https://isthisit.nz/tags/cromwell" class="tag">cromwell <span>(2)</span></a>
    
    
    
    
    <a href="https://isthisit.nz/tags/docker" class="tag">docker <span>(2)</span></a>
    
    
    
    
    <a href="https://isthisit.nz/tags/fable" class="tag">fable <span>(2)</span></a>
    
    
    
    
    <a href="https://isthisit.nz/tags/feliz" class="tag">feliz <span>(2)</span></a>
    
    
    
    
    <a href="https://isthisit.nz/tags/lunar-eclipse" class="tag">lunar-eclipse <span>(2)</span></a>
    
    
    
    
    <a href="https://isthisit.nz/tags/photography-meta" class="tag">photography-meta <span>(2)</span></a>
    
    
    
    
    <a href="https://isthisit.nz/tags/teamcity" class="tag">teamcity <span>(2)</span></a>
    
    
    
    
    <a href="https://isthisit.nz/tags/typescript" class="tag">typescript <span>(2)</span></a>
    
    
    </div>

    <div class="separator">
        <span class="unselectable">
                Œª
        </span>
    </div>

    <div>
        <em>All of this is untrue but it is beautiful</em>
    </div>

    <div class="separator">
        <span class="unselectable">
                Œª
        </span>
    </div>

</div>


</section>

<div id="lightbox" class="lightbox"></div>

<section id="footer">
    <a href="https://isthisit.nz/about">about</a> 
    <span class="unselectable muted icon-item" style="margin-left: 20px; margin-right: 20px">Œ¥</span> 
    <a href="https://isthisit.nz/archive">archive</a>
    <span class="unselectable muted icon-item" style="margin-left: 20px; margin-right: 20px">Œ¥</span>
    <a href="https://analogphotographyassistant.com">APA, an android app for film photographers</a>

    <span class="unselectable muted icon-item" style="margin-left: 20px; margin-right: 20px">Œ¥</span>
    <a href='https://isthisit.nz/index.xml'>.rss</a>
    <span class="unselectable muted icon-item" style="margin-left: 20px; margin-right: 20px">Œ¥</span>
    <a href="mailto:logan@isthisit.nz">logan@isthisit.nz</a>
</section>

    <script async src="https://isthisit.nz/js/lightbox.js"></script>
    <script data-goatcounter="https://isthisit.goatcounter.com/count"  async src="//gc.zgo.at/count.js"></script>

</body>
</html>



